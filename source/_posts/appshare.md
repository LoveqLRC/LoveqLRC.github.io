---
title: appshare
categories: share
tags: share
copyright: true
comments: true
description: 
date: 2019年03月28日15:39:41
top:
photos: 
    - "/img/ui06.JPG"
---
  
移动开发技术简介
<!--more-->
# 移动开发技术简介

## 原生开发

原生应用程序是指某一个移动平台(ios 或 Android)所特有的应用,使用相应平台支持的开发工具和语言，并直接调用系统提供的SDK api。原生开发主要有一下优点：

- 可访问平台提供的全部功能
- 速度快、性能高、可以实现复杂动画及绘制，整体用户体验好

主要缺点

- 平台特点，开发成本高，不同平台必须维护不同代码
- 内容固定，动态化弱，大多数情况下，有新功能更新时只能发版

> 动态化内容需求增大，当需求发生变化时，纯原生应用需要通过版本升级来更新内容，但应用上架，审核是需要周期的，这对高速变化的互联网时代来说是很难接受的。


## 跨平台开发

针对原生开发面临的问题，现已有很多跨平台框架，根据原理不同，主要分为三类：

- H5+原生(Cordova Ionic)
- JavaScript开发+原生渲染(React Native ,Weex)
- 自绘UI+原生(Flutter)

### H5+原生混合开发
这类框架主要原理就是将APP的一部分需要动态变动的内容通过H5来实现，通过原生的网页加载控件来加载，这样一来H5部分可以随时改变而不用发版，动态化需求满足，同时，由于H5代码只需要一次开发，就能同时在Android和IOS两个平台运行，这也可以减少开发成本，也就是说，h5部分功能越多，开发成本就越小。

> 网页加载实质就是一个浏览器，所以对于大多数系统能力都没有访问权限，对于H5不能实现的功能，都需要原生去做。

### JavaScript开发+原生渲染
React Native是Facebook 开源的跨平台移动应用开发框架，是Fackbook早先开源的JS框架React在原生移动应用平台的衍生产物，目前支持IOS和Android两个平台。
React Native中虚拟DOM会通过JavaScriptCore映射为原生控件树。这过程分为两步：

- 布局消息传递，将虚拟DOM布局信息传递给原生
- 原生根据布局信息通过对应的原生控件渲染控件树


> 相对于混合应用，由于React Native是原生控件渲染，所以性能会比混合应用中H5好很多，同时React Native是Web开发技术栈，也只需维护一份代码，同样是跨平台框架


JavaScript开发+原生渲染的方式主要优点

1. Web开发技术栈
2. 原生渲染，性能相比H5好
3. 动态化较好，支持热更新


不足

1. 渲染时需要JavaScript和原生之间通信，在有些场景如拖动可能会因为通信频繁导致卡顿
2. 由于渲染依赖原生控件，不同平台的控件需要单独维护，并且当系统更新时，社区控件可能会滞后


### 自绘UI+原生

自绘UI+原生。这种技术的思路是，通过在不同平台实现一个统一接口的渲染引擎来绘制UI，而不依赖系统原生控件，所以可以做到不同平台UI的一致性。自绘引擎解决的是UI的跨平台问题，如果涉及其它系统能力调用，依然要涉及原生开发。这种平台技术的优点如下

1.性能高；由于自绘引擎是直接调用系统API来绘制UI，所以性能和原生控件接近。

2.灵活、组件库易维护、UI外观保真度和一致性高；由于UI渲染不依赖原生控件，也就不需要根据不同平台的控件单独维护一套组件库，所以代码容易维护。由于组件库是同一套代码、同一个渲染引擎，所以在不同平台，组件显示外观可以做到高保真和高一致性；另外，由于不依赖原生控件，也就不会受原生布局系统的限制，这样布局系统会非常灵活。

不足 ：

1.动态性不足，不能动态下发代码。


# 关于模式的选择，MVC、MVP还是MVVM?

模式没有好坏，只有适不适合，只要运用得当，都可以实现想要的效果，无论是哪种模式，其核心的目标就是高内聚低耦合，达到敏捷开发。

> 这里只介绍Mvp

## MVP

![1645b738c9d09633.jpg](https://upload-images.jianshu.io/upload_images/2018603-55f8c128b7717180.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

 - `View`仅仅负责实现单纯的、独立的UI操作.
 - `Model ` 负责处理数据请求、业务逻辑，不涉及UI操作
 - `Presenter`是`MVP`体系的控制中心，负责给`View`和`Model`安排工作 ，什么时候调用`Model`处理逻辑，什么时候调用`View`反应结果，由`Presenter`控制。

`Mvp`的核心思想就是把`UI`界面和业务逻辑隔离，互相不“知道”，不依赖对方，互不影响。

![timg.jpeg](https://upload-images.jianshu.io/upload_images/2018603-660e142f0615adf4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


### 登录界面
![Screenshot_20190329-103525.jpg](https://upload-images.jianshu.io/upload_images/2018603-93d262b26873b265.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![Screenshot_20190329-103519.jpg](https://upload-images.jianshu.io/upload_images/2018603-89117c6338a23389.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



登录界面包括两部分，一部分是`UI`界面，一部分是业务逻辑。

`UI`界面没什么可以说的，就是我们看到的，随着业务的发展，界面可能会被改，而业务逻辑不一定会改(数据源不一定会变，这是展示的方式变了)。在`Mvp`中这属于`View`。

另一部分是业务逻辑，点击登录的时候，要判断用户名是否为空，密码是否为空，是否记住密码，可能还会有检查版本更新，上传设备信息等等。这些是脱离`UI`界面存在的，也不应依赖于`UI`。在`Mvp`中这属于`Model`。

这样一来无论是`UI`变化还是业务逻辑改变，都不影响，只用修改其中一部分就可以了。



# 思考
为了安全，当前服务器对每个接口都添加了安全验证(当前规定要携带特定的请求头，和两个请求体参数)，app在请求接口时，必须携带这些信息，不然无法通过安全验证，访问不了接口。而在每个接口上都添加这些参数是一件枯燥而又繁琐的事，有什么办法可以解决呢(Aop?,拦截器？)？


![icon_dance.gif](https://upload-images.jianshu.io/upload_images/2018603-5345becd71acf903.gif?imageMogr2/auto-orient/strip)












